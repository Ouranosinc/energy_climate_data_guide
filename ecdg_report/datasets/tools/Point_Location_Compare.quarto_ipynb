{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: 'A tool for dataset comparison: Observational Data at a point location'\n",
        "jupyter: energy-data\n",
        "---\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "## Overview\n",
        "\n",
        "This page contains Python code that can extract and display historical climate data from different sources at a point location for comparison.\n",
        "The code can be run on the PAVICS platform or a locally configured Python environment with [Jupyter Notebook or Jupyter Lab](https://jupyter.org/) functionality enabled.\n",
        "It relys on the data available on PAVICS, but other data from other sources may be introduced.\n",
        "\n",
        "Two versions are shown:\n",
        "\n",
        "* A simple script that may be modified by the user to control the output figure.\n",
        "* A script that generates an interactive dashboard with widgets for the user to control the output of the figure.\n",
        "\n",
        "::: {.callout-warning title=\"Note\"}\n",
        "The code sections below can not be executed on this web page. For them to be run they will need to be copied to a Jupyter Notebook on PAVICS or a local Python environment.\n",
        ":::\n",
        "\n",
        "\n",
        "## A simple script\n",
        "This script generates a figure to compare datasets of historical climate.\n",
        "\n",
        "### First we need to import libraries and define the data\n",
        "The following section determines the content of the figure in terms of the datasets, the point location, the time period and the frequency.\n"
      ],
      "id": "bb5c16ca"
    },
    {
      "cell_type": "code",
      "metadata": {
        "tags": []
      },
      "source": [
        "import xarray as xr\n",
        "import xclim as xc\n",
        "from xclim.core import units\n",
        "from clisops.core.subset import subset_gridpoint\n",
        "import matplotlib.pyplot as plt\n",
        "from datetime import date\n",
        "from dask.diagnostics import ProgressBar\n",
        "import warnings\n",
        "warnings.filterwarnings(action='ignore')\n",
        "# plt.style.available\n",
        "plt.style.use('seaborn-v0_8')\n",
        "\n",
        "# Inputs\n",
        "lat_in = 45.0\n",
        "lon_in = -72.0\n",
        "\n",
        "start_date = date(1991,1,1)\n",
        "end_date = date(2020,12,31)\n",
        "\n",
        "freq = 'year'\n",
        "\n",
        "datasets = {\n",
        "    \"ECCC_AHCCD_gen3_temperature\": \"https://pavics.ouranos.ca/twitcher/ows/proxy/thredds/dodsC/datasets/station_obs/ECCC_AHCCD_gen3_temperature.ncml\",\n",
        "    #\"ECCC_AHCCD_gen2_precipitation\": \"https://pavics.ouranos.ca/twitcher/ows/proxy/thredds/dodsC/datasets/station_obs/ECCC_AHCCD_gen2_precipitation.ncml\",\n",
        "    \"NRCANMet_v2\": \"https://pavics.ouranos.ca/twitcher/ows/proxy/thredds/dodsC/datasets/gridded_obs/nrcan_v2.ncml\",\n",
        "    \"RDRSv2.1\": \"https://pavics.ouranos.ca/twitcher/ows/proxy/thredds/dodsC/datasets/reanalyses/day_RDRSv2.1_NAM.ncml\",\n",
        "    \"ERA5-Land\": \"https://pavics.ouranos.ca/twitcher/ows/proxy/thredds/dodsC/datasets/reanalyses/day_ERA5-Land_NAM.ncml\"\n",
        "    }\n",
        "\n",
        "def aggregate(ds, var, freq='annual'):\n",
        "    freqs={\n",
        "        'month': 'MS',\n",
        "        'season': 'QS-DEC',\n",
        "        'year': 'YS'\n",
        "    }\n",
        "    functs = {\n",
        "        'pr': xc.indicators.atmos.precip_average,\n",
        "        'tasmin': xc.indicators.atmos.tn_mean,\n",
        "        'tasmax': xc.indicators.atmos.tx_mean,\n",
        "    }\n",
        "    return functs[var](ds=ds, freq=freqs[freq])"
      ],
      "id": "54ba6f5c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### In the second step we create the figure\n",
        "The next section of code will load the data for the selected location, time period, location and frequency and generate the figure.\n"
      ],
      "id": "c48f5179"
    },
    {
      "cell_type": "code",
      "metadata": {
        "tags": []
      },
      "source": [
        "fig, ax = plt.subplots(1,1, figsize=(15,5))\n",
        "for idx, (name, url) in enumerate(datasets.items()):\n",
        "    ds = xr.open_dataset(url, chunks={'time': -1, 'lat': 50, 'lon': 50}, decode_timedelta=False)\n",
        "    print(f\"Loading {name} ...\") \n",
        "    #display(ds) \n",
        "    ds_pt = subset_gridpoint(ds,\n",
        "                             lat=lat_in,\n",
        "                             lon=lon_in,\n",
        "                             start_date=start_date.strftime('%Y-%m-%d'),\n",
        "                             end_date=end_date.strftime('%Y-%m-%d'),\n",
        "                             add_distance=True)\n",
        "    \n",
        "    dist = f\"dist = {ds_pt.distance.values/1000:0.1f} km\"\n",
        "    #print(dist)\n",
        "    \n",
        "    # Style\n",
        "    color = f\"C{idx}\"\n",
        "    line_styles = {\"tasmin\": \":\", \"tasmax\": \"--\"}\n",
        "    \n",
        "    tmp_vars = ['tasmin', 'tasmax']\n",
        "    if all(var in ds.data_vars for var in tmp_vars):\n",
        "        for var in tmp_vars:\n",
        "\n",
        "            ds_var = aggregate(ds=ds_pt, var=var, freq=freq)\n",
        "\n",
        "            if 'units' in ds_var.attrs and ds_var.units == 'K':\n",
        "                ds_var = units.convert_units_to(ds_var, \"degC\")\n",
        "            #display(ds_pt)\n",
        "\n",
        "            ds_var.plot.line(ax=ax,\n",
        "                            linestyle=line_styles[var],\n",
        "                            color=color,\n",
        "                            label=f\"{name} - {dist}\" if var == 'tasmin' else None,\n",
        "                            add_legend=False\n",
        "                           )\n",
        "plt.legend(bbox_to_anchor=(1.05, 1.0), loc='upper left')\n",
        "ax.set_ylabel(f\"Minimum and maximum\\n{freq} temperature [˚C]\")\n",
        "plt.title(f\"{freq.capitalize()} Minimum and Maximum Temperatures from Multiple Datasets between {start_date.year} and {end_date.year}\");"
      ],
      "id": "29182b77",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Modifying the two code sections above allows the user to adjust the content of the figure.\n",
        "\n",
        "## A script to create an interactive dashboard\n",
        "\n",
        "### Preparations for the dashboard\n",
        "The following section of code defines functions that will be used by the dashboard to update the figure based on user input.\n"
      ],
      "id": "cfd43264"
    },
    {
      "cell_type": "code",
      "metadata": {
        "tags": []
      },
      "source": [
        "# Callback function to create the Matplotlib plot\n",
        "def create_plot(xlim, freq, var):\n",
        "    \n",
        "    start, end = xlim\n",
        "    start = date(start,1,1)\n",
        "    end = date(end,12,31)\n",
        "    \n",
        "    fig, ax = plt.subplots(figsize=(9,3))\n",
        "    \n",
        "    for idx, (name, file) in enumerate(data_files.items()):\n",
        "        # Style:\n",
        "        color = f\"C{idx}\"\n",
        "        line_styles = {\"tasmin\": \":\", \"tasmax\": \"--\"}\n",
        "\n",
        "        tmp_vars = ['tasmin', 'tasmax']\n",
        "        ds = xr.open_dataset(file)\n",
        "        dist = f\"dist = {ds.distance.values/1000:0.1f} km\"\n",
        "        if all(var in ds.data_vars for var in tmp_vars):\n",
        "            for var in tmp_vars:\n",
        "\n",
        "                ds_var = aggregate(ds=ds, var=var, freq=freq)\n",
        "\n",
        "                if 'units' in ds_var.attrs and ds_var.units == 'K':\n",
        "                    ds_var = units.convert_units_to(ds_var, \"degC\")\n",
        "                #display(ds_pt)\n",
        "\n",
        "                ds_var.sel(time=slice(start, end)).plot.line(ax=ax,\n",
        "                                linestyle=line_styles[var],\n",
        "                                linewidth=1,\n",
        "                                color=color,\n",
        "                                label=f\"{name} - {dist}\" if var == 'tasmin' else None,\n",
        "                                add_legend=False\n",
        "                               )\n",
        "    ax.set_ylabel(f\"Minimum and maximum\\n{freq} temperature [˚C]\")\n",
        "    ax.xaxis.label.set_fontsize(8)  # Update x-axis label font size\n",
        "    ax.yaxis.label.set_fontsize(8)  # Update y-axis label font size\n",
        "    ax.tick_params(axis='x', labelsize=6)  # Update x-axis tick labels font size\n",
        "    ax.tick_params(axis='y', labelsize=6)  # Update y-axis tick labels font size\n",
        "    plt.legend(bbox_to_anchor=(1.05, 1.0), loc='upper left', fontsize=6)\n",
        "    plt.title(f\"{freq.capitalize()} Minimum and Maximum Temperatures from Multiple Datasets between {start.year} and {end.year}\", fontsize=8);\n",
        "    \n",
        "    plt.close(fig)  # Prevent Matplotlib from displaying the figure immediately\n",
        "    return fig\n",
        "\n",
        "# callback function to exract data for point location.\n",
        "def extract_data(lat, lon):\n",
        "    \n",
        "    # ToDo: delete old points data!\n",
        "    data_files = {}\n",
        "    for idx, (name, url) in enumerate(datasets.items()):\n",
        "        ds = xr.open_dataset(url, chunks={'time': -1, 'lat': 50, 'lon': 50}, decode_timedelta=False)\n",
        "        print(f\"{10*'-'} Reading {name} {10*'-'}\") \n",
        "        #display(ds) \n",
        "        ds_pt = subset_gridpoint(ds,\n",
        "                                 lat=lat,\n",
        "                                 lon=lon,\n",
        "                                 add_distance=True)\n",
        "        # we need to remove 0D variables (applies to AHCCD data only)\n",
        "        ds_pt = ds_pt.drop_vars([k for k in ds_pt.variables.keys() if ds_pt[k].dtype == 'O'])\n",
        "        #display(ds_pt)\n",
        "        file = f'tmp/{name}_lat{lat}_lon{lon}.nc'\n",
        "        #print(f\"Writing {file} ...\")\n",
        "        ds_pt.to_netcdf(file)\n",
        "        data_files[name] = file\n",
        "    return data_files"
      ],
      "id": "279797ef",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Loading the data\n",
        "The next block of code loads data from a default grid point.\n"
      ],
      "id": "d0881207"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# ToDo: load with AHCCD data\n",
        "datasets = {\n",
        "    \"ECCC_AHCCD_gen3_temperature\": \"https://pavics.ouranos.ca/twitcher/ows/proxy/thredds/dodsC/datasets/station_obs/ECCC_AHCCD_gen3_temperature.ncml\",\n",
        "    #\"ECCC_AHCCD_gen2_precipitation\": \"https://pavics.ouranos.ca/twitcher/ows/proxy/thredds/dodsC/datasets/station_obs/ECCC_AHCCD_gen2_precipitation.ncml\",\n",
        "    \"NRCANMet_v2\": \"https://pavics.ouranos.ca/twitcher/ows/proxy/thredds/dodsC/datasets/gridded_obs/nrcan_v2.ncml\",\n",
        "    \"RDRSv2.1\": \"https://pavics.ouranos.ca/twitcher/ows/proxy/thredds/dodsC/datasets/reanalyses/day_RDRSv2.1_NAM.ncml\",\n",
        "    \"ERA5-Land\": \"https://pavics.ouranos.ca/twitcher/ows/proxy/thredds/dodsC/datasets/reanalyses/day_ERA5-Land_NAM.ncml\"\n",
        "    }\n",
        "\n",
        "with ProgressBar():\n",
        "    data_files = extract_data(lat_in, lon_in)\n",
        "\n",
        "print(data_files)"
      ],
      "id": "574ed24b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Creating the interactive dashboard\n",
        "The following code section uses the panel library to create a user interface to interactively modify the figure. It uses the above functions to update the figure accordingly.\n"
      ],
      "id": "73744005"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "import pandas as pd\n",
        "import matplotlib.pyplot as plt\n",
        "import panel as pn\n",
        "\n",
        "# Initialize Panel\n",
        "pn.extension()\n",
        "\n",
        "# Widgets\n",
        "xlim_slider = pn.widgets.RangeSlider(name=\"Years\", start=1950, end=2025, value=(1950, 2025), step=1)\n",
        "lat_input = pn.widgets.TextInput(name=\"Latitude\", placeholder=\"Enter Latitude\", value=str(lat_in), width=125)\n",
        "lon_input = pn.widgets.TextInput(name=\"Longitude\", placeholder=\"Enter Longitude\", value=str(lon_in), width=125)\n",
        "freq_dropdown = pn.widgets.Select(name=\"Frequency\", options=['month', 'season', 'year'], value='year', width=100)\n",
        "var_dropdown = pn.widgets.Select(name=\"Variable\", options=['Temperature', 'Precipitation'], width=150)\n",
        "var_stats = pn.widgets.Select(name=\"Statistic\", options=['mean', 'maximum', 'minimum'], width=150)\n",
        "\n",
        "# Dynamic Matplotlib plot\n",
        "dynamic_plot = pn.bind(create_plot, xlim=xlim_slider, freq=freq_dropdown, var=var_dropdown)\n",
        "\n",
        "# Layout\n",
        "controls = pn.Row(\"### Controls\", xlim_slider, lat_input, lon_input, freq_dropdown, var_dropdown, var_stats)\n",
        "dashboard = pn.Column(controls, pn.pane.Matplotlib(dynamic_plot, tight=True))\n",
        "\n",
        "# Serve the dashboard\n",
        "dashboard"
      ],
      "id": "ec24e978",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "energy-data",
      "language": "python",
      "display_name": "energy-data",
      "path": "/home/braun/.local/share/jupyter/kernels/energy-data"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}